[{"categories":["算法","力扣","leetcode"],"content":"题目描述 给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。 一步操作中，你将创建一个新数组 arr ，对于每个 i ： 如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2] 如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2] 然后将 arr 赋值给 perm 。 要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。 示例 1： 输入：n = 2 输出：1 解释：最初，perm = [0,1] 第 1 步操作后，perm = [0,1] 所以，仅需执行 1 步操作 示例 2： 输入：n = 4 输出：2 解释：最初，perm = [0,1,2,3] 第 1 步操作后，perm = [0,2,1,3] 第 2 步操作后，perm = [0,1,2,3] 所以，仅需执行 2 步操作 示例 3： 输入：n = 6 输出：4 提示： 2 \u003c= n \u003c= 1000 n 是一个偶数 ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:1:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"分析 当n=4时，0123 -\u003e 0213 -0123, 我们发现第一位和最后一位位置不变，只有中间的数字在动 当n=6时，012345 -\u003e 024135 -\u003e 043215 -\u003e 031425 -\u003e 012345, 和上面是一样的规律 同时我们发现，当1回到原来的位置时，所有的数字都回到原来的位置上了 所以，我可以数字 1 作为锚点，当数字 1 回到原点则所有数字都回到原位 ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:2:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"解法 func reinitializePermutation(n int) int { // 用1作为锚点 tmp := 1 // 记录操作数 cnt := 0 for { if tmp%2 == 1 { tmp = n/2 + (tmp-1)/2 } else { tmp /= 2 } // 操作+1 cnt++ // 数字1回到原点，则退出循环 if tmp == 1 { break } } return cnt } ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:3:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"题目描述: 给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 示例 1： 输入：words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\" 输出：2 解释：以 \"at\" 作为前缀的字符串有两个，分别是：\"attention\" 和 \"attend\" 。 示例 2： 输入：words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\" 输出：0 解释：不存在以 \"code\" 作为前缀的字符串。 分析： 题目非常简单。可以使用语言内置库函数，记不住库函数的话只能自己实现了。 解法一：使用语言内置库函数 func prefixCount(words []string, pref string) int { cnt := 0 for _, v := range words{ if strings.HasPrefix(v, pref){ cnt++ } } return cnt } 解法二：自己实现函数 func prefixCount(words []string, pref string) int { cnt := 0 for _, v := range words{ if hasPrefix(v, pref){ cnt++ } } return cnt } // hasPrefix 判断str是否有前缀prefix func hasPrefix(str, prefix string) bool{ // 如果前缀比字符串本身还长，肯定是false if len(prefix) \u003e len(str) { return false }else{ for i := 0; i \u003c len(prefix); i++{ if str[i] != prefix[i] { return false } } } return true } TODO： 重新复习下go语言中和字符串操作相关的库strings 链接： 2185. 统计包含给定前缀的字符串 ","date":"2023-01-08","objectID":"/posts/2185.%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["每日一练"],"title":"2185.统计包含给定前缀的字符串","uri":"/posts/2185.%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"我喜欢写go，因为适合我. ","date":"2022-09-04","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"来都来了，来的都是客，说点什么把~ ","date":"2022-09-04","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":["生活"],"content":"这是一个开始，以后便在这里记录一些见识和感悟……! ","date":"2022-03-05","objectID":"/posts/start/:0:0","tags":["闲聊"],"title":"开始","uri":"/posts/start/"}]
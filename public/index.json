[{"categories":["日常"],"content":"大概是一个多月前，我阳了。那天是周五，晚上就感觉整个人很酸疼，潜意识里也没有想到是发烧了，然后自己还去洗了个澡，这也就是痛苦的开始了。晚上睡觉的时候很难受，酸疼得一直迷迷糊糊睡不着。结果第二天一醒来就更难受了，当时自己身边也没有药。我直接奔向了附近的社康医院，开了两颗布洛芬（只给开两颗，也是醉了），自己也没有温度计，连多少度了都不知道。问医院借了一根，量出来38.9°。回家直接躺了两天，东西也吃不下…… 那时候比较痛苦的一是基本买不到药，温度计也买不到。我在美团上抢了一个电子温度计，太不靠谱了。前后几分钟温度可以差好几度，真的别买！后续药吃完了还是发烧，又继续去医院排队拿药，不过这次人太多了，排了好久，医院都说了药不一定够，这……万幸还是拿到药，后续就是各种症状，刀片嗓，水泥鼻，应有尽有。 差不多两周后情况基本好了，但是又开始咳嗽，一言难尽。 元旦后开始上班，我开始觉得阳过之后就不用担心什么了，虽然口罩还是日常戴着。昨天周六早上一起床全身有点酸痛，我以为没休息好。还去了医院一趟。后面感觉人越来越难受，吃了午饭就一觉休息到4点多，然后跑了三家药店才买到水银温度计，一量38.3°，肯定是又阳了。转念一想周五晚上又洗了一次澡，MLGB，历史总是惊人的相似。 今天早上起来体温降到了37°，不清楚会不会反反复复，因为上次也是一直反复。刚开始抗原也测不出，真是难受，今天的感觉就是全身酸疼。希望赶紧好起来吧，新冠这东西太痛苦了。 ","date":"2023-01-15","objectID":"/posts/%E6%96%B0%E5%86%A0%E5%8F%88%E9%98%B3%E4%BA%86/:0:0","tags":["日常"],"title":"新冠又阳了","uri":"/posts/%E6%96%B0%E5%86%A0%E5%8F%88%E9%98%B3%E4%BA%86/"},{"categories":["算法","力扣","leetcode"],"content":"题目描述 给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。 比方说，字符串 \"(name)is(age)yearsold\" 中，有 两个 括号对，分别包含键 \"name\" 和 \"age\" 。 你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。 你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要： 将 keyi 和括号用对应的值 valuei 替换。 如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 \"?\" 替换（不需要引号）。 knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。 请你返回替换 所有 括号对后的结果字符串。 示例 1： 输入：s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]] 输出：\"bobistwoyearsold\" 解释： 键 \"name\" 对应的值为 \"bob\" ，所以将 \"(name)\" 替换为 \"bob\" 。 键 \"age\" 对应的值为 \"two\" ，所以将 \"(age)\" 替换为 \"two\" 。 示例 2： 输入：s = \"hi(name)\", knowledge = [[\"a\",\"b\"]] 输出：\"hi?\" 解释：由于不知道键 \"name\" 对应的值，所以用 \"?\" 替换 \"(name)\" 。 示例 3： 输入：s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]] 输出：\"yesyesyesaaa\" 解释：相同的键在 s 中可能会出现多次。 键 \"a\" 对应的值为 \"yes\" ，所以将所有的 \"(a)\" 替换为 \"yes\" 。 注意，不在括号里的 \"a\" 不需要被替换。 提示： 1 \u003c= s.length \u003c= 105 0 \u003c= knowledge.length \u003c= 105 knowledge[i].length == 2 1 \u003c= keyi.length, valuei.length \u003c= 10 s 只包含小写英文字母和圆括号 '(' 和 ')' 。 s 中每一个左圆括号 '(' 都有对应的右圆括号 ')' 。 s 中每对括号内的键都不会为空。 s 中不会有嵌套括号对。 keyi 和 valuei 只包含小写英文字母。 knowledge 中的 keyi 不会重复。 ","date":"2023-01-12","objectID":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/:1:0","tags":["每日一练"],"title":"1807.替换字符串中的括号内容","uri":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/"},{"categories":["算法","力扣","leetcode"],"content":"分析 这道题比较直接，不用绕什么弯子。先用hash表将 knowledge 内容存起来，然后直接遍历整个字符串进行替换。 ","date":"2023-01-12","objectID":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/:2:0","tags":["每日一练"],"title":"1807.替换字符串中的括号内容","uri":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/"},{"categories":["算法","力扣","leetcode"],"content":"解法 func evaluate(s string, knowledge [][]string) string { m := map[string]string{} for _, v := range knowledge { m[v[0]] = v[1] } rs := []byte{} for i := 0; i \u003c len(s); i++ { l := 0 r := 0 if s[i] == '(' { l = i + 1 r = i + 1 for s[r] != ')' { r++ } i = r if v, exist := m[s[l:r]]; !exist { rs = append(rs, '?') } else { rs = append(rs, v...) } } else { rs = append(rs, s[i]) } } return string(rs) } ","date":"2023-01-12","objectID":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/:3:0","tags":["每日一练"],"title":"1807.替换字符串中的括号内容","uri":"/posts/1807.%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/"},{"categories":["算法","力扣","leetcode"],"content":"题目描述 给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。 一步操作中，你将创建一个新数组 arr ，对于每个 i ： 如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2] 如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2] 然后将 arr 赋值给 perm 。 要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。 示例 1： 输入：n = 2 输出：1 解释：最初，perm = [0,1] 第 1 步操作后，perm = [0,1] 所以，仅需执行 1 步操作 示例 2： 输入：n = 4 输出：2 解释：最初，perm = [0,1,2,3] 第 1 步操作后，perm = [0,2,1,3] 第 2 步操作后，perm = [0,1,2,3] 所以，仅需执行 2 步操作 示例 3： 输入：n = 6 输出：4 提示： 2 \u003c= n \u003c= 1000 n 是一个偶数 ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:1:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"分析 当n=4时，0123 -\u003e 0213 -0123, 我们发现第一位和最后一位位置不变，只有中间的数字在动 当n=6时，012345 -\u003e 024135 -\u003e 043215 -\u003e 031425 -\u003e 012345, 和上面是一样的规律 同时我们发现，当1回到原来的位置时，所有的数字都回到原来的位置上了 所以，我可以数字 1 作为锚点，当数字 1 回到原点则所有数字都回到原位 ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:2:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"解法 func reinitializePermutation(n int) int { // 用1作为锚点 tmp := 1 // 记录操作数 cnt := 0 for { if tmp%2 == 1 { tmp = n/2 + (tmp-1)/2 } else { tmp /= 2 } // 操作+1 cnt++ // 数字1回到原点，则退出循环 if tmp == 1 { break } } return cnt } ","date":"2023-01-09","objectID":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/:3:0","tags":["每日一练"],"title":"1806.还原排列的最少操作步数","uri":"/posts/1806.%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"},{"categories":["算法","力扣","leetcode"],"content":"题目描述: 给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 示例 1： 输入：words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\" 输出：2 解释：以 \"at\" 作为前缀的字符串有两个，分别是：\"attention\" 和 \"attend\" 。 示例 2： 输入：words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\" 输出：0 解释：不存在以 \"code\" 作为前缀的字符串。 分析： 题目非常简单。可以使用语言内置库函数，记不住库函数的话只能自己实现了。 解法一：使用语言内置库函数 func prefixCount(words []string, pref string) int { cnt := 0 for _, v := range words{ if strings.HasPrefix(v, pref){ cnt++ } } return cnt } 解法二：自己实现函数 func prefixCount(words []string, pref string) int { cnt := 0 for _, v := range words{ if hasPrefix(v, pref){ cnt++ } } return cnt } // hasPrefix 判断str是否有前缀prefix func hasPrefix(str, prefix string) bool{ // 如果前缀比字符串本身还长，肯定是false if len(prefix) \u003e len(str) { return false }else{ for i := 0; i \u003c len(prefix); i++{ if str[i] != prefix[i] { return false } } } return true } TODO： 重新复习下go语言中和字符串操作相关的库strings 链接： 2185. 统计包含给定前缀的字符串 ","date":"2023-01-08","objectID":"/posts/2185.%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["每日一练"],"title":"2185.统计包含给定前缀的字符串","uri":"/posts/2185.%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"我喜欢写go，因为适合我. ","date":"2022-09-04","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"来都来了，来的都是客，说点什么把~ ","date":"2022-09-04","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":["生活"],"content":"这是一个开始，以后便在这里记录一些见识和感悟……! ","date":"2022-03-05","objectID":"/posts/start/:0:0","tags":["闲聊"],"title":"开始","uri":"/posts/start/"}]